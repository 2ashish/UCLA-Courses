;;;; CS161A Asignment 1 Solution
;;;; Name: Ashish Kumar Singh
;;;; UID: 105479019


;;; Using the binary search tree property, if searching element is equal to root return true, else if it is greater than root check in right sub tree else check in left subtree
(defun TREE-CONTAINS (N TREE)
    ;; Inputs: TREE is an ordered tree, N is a number that we need to check in the TREE
    ;; Output: A boolean denoting whether the number N is present in TREE or not
    (cond
        ((null TREE)NIL)
        ((atom TREE) (= N TREE))
        ((null (cdr TREE))
            (cond
                ((= N (car TREE))t)
                (t NIL)
            )
        )
        ((equal N (cadr TREE))t)
        ((> N (cadr TREE))(TREE-CONTAINS N (cddr TREE)))
        ((< N (cadr TREE))(TREE-CONTAINS N (car TREE)))
    )
)


;;; ordered tree will have the maximum number in the rightmost leaf node, so we traverse to right subtree at every node till we reach a leaf node
(defun TREE-MAX (TREE)
    ;; Inputs: TREE is an ordered tree containing numbers
    ;; Output: maximum number in the TREE
    (cond
        ((null TREE)NIL)
        ((atom TREE) TREE)
        ((null (cdr TREE)) (TREE-MAX (car TREE)))
        ((null (cddr TREE)) (TREE-MAX (cadr TREE)))
        (t (TREE-MAX (cddr TREE)))
    )
)


;;; post order is generated by traversing the left sub-tree, then right sub-tree then the root
(defun TREE-ORDER (TREE)
    ;; Inputs: TREE is an ordered tree containing numbers
    ;; Output: post order list of the numbers in the TREE
    (cond
        ((null TREE)NIL)
        ((atom TREE) (cons TREE NIL))
        ((null (cdr TREE)) (TREE-ORDER (car TREE)))
        (t (let 
                ((left (car TREE)
                )
                (right (cddr TREE)
                )
                (root (cadr TREE))
                )
            (append (TREE-ORDER left) (TREE-ORDER right)  (cons root NIL)   )
            )
        )
    )
)


;;; keep taking rest elements in list and decrease START till it becomes 0, then recursively keep appending first element and decrease LEN till it becomes 0
(defun SUB-LIST (L START LEN)
    ;; Inputs: L is a list, START and LEN are two non-negative integers
    ;; Output: sub-list of L starting at position START and having length LEN
    (cond
        ((= LEN 0 )NIL)
        ((>= START (length L))NIL)
        ((> START 0) (SUB-LIST (cdr L) (- START 1) LEN))
        (t (cons (car L) (SUB-LIST (cdr L) 0  (- LEN 1) ) ))
    )
)


;;; use the previous defined sublist function to break the list in two parts
(defun SPLIT-LIST (L )
    ;; Inputs: L is a list
    ;; Output: list of two lists L1, L2 such that (length of L1 - length of L2) is 0 or 1
    (cond
        ((null L ) '(NIL NIL))
        ((< (length L) 3) (list (SUB-LIST L 0 1) (SUB-LIST L 1 (- (length L) 1))) )
        (t (let*(
                ;(len2 (floor (length L) 2))
                (len2 (if (oddp (length L)) (/ (- (length L) 1) 2) (/ (length L) 2))
                )
                (len1 (- (length L) len2))
                )
        
            (list (SUB-LIST L 0 len1) (SUB-LIST L len1 len2) )
            )
        
        )
    )
)


;;; recursively check the height of left and right sub tree then, return their maximum increased by 1
(defun BTREE-HEIGHT (TREE)
    ;; Inputs: TREE is a binary tree
    ;; Output: height of the TREE, longest path from the root node to the farthest leaf node.
    (cond
        ((null TREE) 0 )
        ((atom TREE) 0 )
        (t (let*(
                (lheight (BTREE-HEIGHT (car TREE)))
                (rheight (BTREE-HEIGHT (cadr TREE)))
                )
            (if (> lheight rheight) (+ lheight 1) (+ rheight 1))
            )
            
        )
    )
)


;;; split the LEAVES in two parts using SPLIT-LIST function defined before, than recursively form binary tree for both, then combine
(defun LIST2BTREE (LEAVES)
    ;; Inputs: LEAVES is a non-empty list of atoms
    ;; Output: a binary tree such that the leaf nodes are the elements of the list LEAVES, left branch has always equal or 1 more nodes than right branch
    (cond
        ((null LEAVES) NIL )
        ((equal LEAVES '(NIL)) NIL)
        ((null (cdr LEAVES)) (car LEAVES) )
        (t (let*(
                (lr (SPLIT-LIST LEAVES))
                (l (car lr))
                (r (cadr lr))
                )
            (list (LIST2BTREE l) (LIST2BTREE r))
            
            )
            
        )
    )
)


;;; recursively form list for left and right sub tree then append them together
(defun BTREE2LIST (TREE)
    ;; Inputs: TREE is a binary tree
    ;; Output: A list of all the leaf nodes
    (cond
        ((null TREE) '(NIL) )
        ((atom TREE) (list TREE ))
        (t (let*(
                (left (BTREE2LIST (car TREE)))
                (right (BTREE2LIST (cadr TREE)))
                )
            (append left right)
            )
            
        )
    )
)


;;; recursively check first and rest of both expression and then take and
(defun IS-SAME (E1 E2)
    ;; Inputs: E1 and E2 are two lisp expression with atoms as numbers
    ;; Output: A boolean representing whether the expressions are identical or not
    (cond
        ;((not (= (length E1) (length E2) )) NIL)
        ((AND (null E1) (null E2)) t )
        ((AND (atom E1) (not (atom E2))) NIL )
        ((AND (not (atom E1)) (atom E2)) NIL )
        ((AND (atom E1) (atom E2)) (= E1 E2) )
        (t (and (IS-SAME (car E1) (car E2) ) (IS-SAME (cdr E1) (cdr E2) )))
    )
)


;;; reccursively append the first element of E2 to E1, then call FLATTEN-APPEND for the rest of E2
(defun FLATTEN-APPEND (E1 E2)
    ;; Inputs: E1 and E2 are two lisp expression with atoms as numbers
    ;; Output: A list with all atoms of E2 appended to E1
    (cond
        ((null E2) E1 )
        ((atom E2) (append E1 (cons E2 NIL) ))
        (t 
            (FLATTEN-APPEND (FLATTEN-APPEND E1 (car E2)) (cdr E2))
        )
    )
)


;testcases
;TREE-CONTAINS
(write-line "TREE-CONTAINS testcases")
(write (TREE-CONTAINS 3 3 ))                (FRESH-LINE)
(write (TREE-CONTAINS 2 3 ))                (FRESH-LINE)
(write (TREE-CONTAINS 2 '() ))              (FRESH-LINE)
(write (TREE-CONTAINS 2 '(1 2) ))           (FRESH-LINE)
(write (TREE-CONTAINS 3 '((1 2 3) 7) ))     (FRESH-LINE)
(write (TREE-CONTAINS 2 '(1 3 5) ))         (FRESH-LINE)
(write (TREE-CONTAINS 3 '(1 3 5) ))         (FRESH-LINE)
(write (TREE-CONTAINS 3 '(1 2 3) ))         (FRESH-LINE)
(write (TREE-CONTAINS 3 '((1 2 3) 7 8)))    (FRESH-LINE)
(write (TREE-CONTAINS 4 '((1 2 3) 7 8)))    (FRESH-LINE)

;TREE-MAX
(write-line "TREE-MAX testcases")
(write (TREE-MAX 1 ))                       (FRESH-LINE)
(write (TREE-MAX '(1 2 3)))                 (FRESH-LINE)
(write (TREE-MAX '(1 2)))                   (FRESH-LINE)
(write (TREE-MAX '((1 2 3) 7)))             (FRESH-LINE)
(write (TREE-MAX '((1 2 3) 7 8)))           (FRESH-LINE)
(write (TREE-MAX '((1 2 3) 7 (8 9 10))))    (FRESH-LINE)

;TREE-ORDER
(write-line "TREE-ORDER testcases")
(write (TREE-ORDER '(1) ))                  (FRESH-LINE)
(write (TREE-ORDER '(1 2 3)))               (FRESH-LINE)
(write (TREE-ORDER '(1 2 )))                (FRESH-LINE)
(write (TREE-ORDER '((1 2 3) 7  )))         (FRESH-LINE)
(write (TREE-ORDER '((1 2 3) 7 8)))         (FRESH-LINE)
(write (TREE-ORDER '((1 2 3) 7 (8 9))))     (FRESH-LINE)
(write (TREE-ORDER '((1 2 3) 7 (8 9 10))))  (FRESH-LINE)

;SUB-LIST
(write-line "SUB-LIST testcases")
(write (SUB-LIST '() 0 0))                  (FRESH-LINE)
(write (SUB-LIST '(a b c d) 0 3))           (FRESH-LINE)
(write (SUB-LIST '(a b c d) 3 1))           (FRESH-LINE)
(write (SUB-LIST '(a b c d) 2 0))           (FRESH-LINE)
(write (SUB-LIST '(a b c d) 4 4))           (FRESH-LINE)
(write (SUB-LIST '(a (b b) c (d e f)) 1 3)) (FRESH-LINE)

;SPLIT-LIST
(write-line "SPLIT-LIST testcases")   
(write (SPLIT-LIST '(  ) ))                 (FRESH-LINE)
(write (SPLIT-LIST '(a ) ))                 (FRESH-LINE)
(write (SPLIT-LIST '(a b) ))                (FRESH-LINE)
(write (SPLIT-LIST '(a b c) ))              (FRESH-LINE)
(write (SPLIT-LIST '(a b c d) ))            (FRESH-LINE)
(write (SPLIT-LIST '(a b c d e) ))          (FRESH-LINE)
(write (SPLIT-LIST '(a b c d e f) ))        (FRESH-LINE)

;BTREE-HEIGHT
(write-line "BTREE-HEIGHT testcases")
(write (BTREE-HEIGHT 1))                                (FRESH-LINE)
(write (BTREE-HEIGHT '(1 2)))                           (FRESH-LINE)
(write (BTREE-HEIGHT '(1 (2 3))))                       (FRESH-LINE)
(write (BTREE-HEIGHT '((1 2) (3 4))))                   (FRESH-LINE)
(write (BTREE-HEIGHT '((1 (2 3)) ((4 5) (6 7)))))       (FRESH-LINE)
(write (BTREE-HEIGHT '(((1 2) (3 4)) ((5 6) (7 8)))))   (FRESH-LINE)

;LIST2BTREE
(write-line "LIST2BTREE testcases")
(write (LIST2BTREE '(1)))                   (FRESH-LINE)
(write (LIST2BTREE '(1 2)))                 (FRESH-LINE)
(write (LIST2BTREE '(1 2 3)))               (FRESH-LINE)
(write (LIST2BTREE '(1 2 3 4)))             (FRESH-LINE)
(write (LIST2BTREE '(1 2 3 4 5)))           (FRESH-LINE)
(write (LIST2BTREE '(1 2 3 4 5 6 7)))       (FRESH-LINE)
(write (LIST2BTREE '(1 2 3 4 5 6 7 8)))     (FRESH-LINE)
(write (LIST2BTREE '(1 2 3 4 5 6 7 8 9)))   (FRESH-LINE)

;BTREE2LIST
(write-line "BTREE2LIST testcases")
(write (BTREE2LIST '()))                                (FRESH-LINE)
(write (BTREE2LIST 1))                                  (FRESH-LINE)
(write (BTREE2LIST '(1 2)))                             (FRESH-LINE)
(write (BTREE2LIST '((1 2) 3)))                         (FRESH-LINE)
(write (BTREE2LIST '((1 2) (3 4))))                     (FRESH-LINE)
(write (BTREE2LIST '(((1 2) (3 4)) ((5 6) 7))))         (FRESH-LINE)
(write (BTREE2LIST '(((1 2) (3 4)) ((5 6) (7 8)))))     (FRESH-LINE)

;LIST2LIST
(write-line "LIST2LIST testcases")
(write (BTREE2LIST(LIST2BTREE '(1))))                   (FRESH-LINE)
(write (BTREE2LIST(LIST2BTREE '(1 2))))                 (FRESH-LINE)
(write (BTREE2LIST(LIST2BTREE '(1 2 3))))               (FRESH-LINE)
(write (BTREE2LIST(LIST2BTREE '(1 2 3 4))))             (FRESH-LINE)
(write (BTREE2LIST(LIST2BTREE '(1 2 3 4 5 6 7))))       (FRESH-LINE)
(write (BTREE2LIST(LIST2BTREE '(1 2 3 4 5 6 7 8))))     (FRESH-LINE)

;BTREE2BTREE
(write-line "BTREE2BTREE testcases")
(write (LIST2BTREE (BTREE2LIST '()))  )                              (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST 1)) )                                 (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST '(1 2))))                             (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST '((1 2) 3))))                         (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST '((1 2) (3 4)))))                     (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST '(((1 2) (3 4)) ((5 6) 7)))))         (FRESH-LINE)
(write (LIST2BTREE (BTREE2LIST '(((1 2) (3 4)) ((5 6) (7 8))))))     (FRESH-LINE)

;IS-SAME
(write-line "IS-SAME testcases")
(write (IS-SAME '() NIL))                               (FRESH-LINE)
(write (IS-SAME '(1) '(1)))                             (FRESH-LINE)
(write (IS-SAME '(1 2 3) '(1 2 3)))                     (FRESH-LINE)
(write (IS-SAME '((1 2 3) 7 8) '((1 2 3) 7 8)))         (FRESH-LINE)
(write (IS-SAME '(1 2 3 7 8) '((1 2 3) 7 8)))           (FRESH-LINE)


;FLATTEN-APPEND
(write-line "FLATTEN-APPEND testcases")
(write (FLATTEN-APPEND '(0 1) NIL))                     (FRESH-LINE)
(write (FLATTEN-APPEND '(0 1) '2))                      (FRESH-LINE)
(write (FLATTEN-APPEND '(0 1) '(2 (3 4) 5 6)))          (FRESH-LINE)
(write (FLATTEN-APPEND '(0 (1 (2 3)) 4) '(5 (6) 7)))    (FRESH-LINE)
(write (FLATTEN-APPEND NIL '(1 2 ((3) 4) 5 (6 7) 8)))   (FRESH-LINE)

(write-line "Done")
;(write '(NIL NIL))


